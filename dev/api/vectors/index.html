<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vectors · SafePETSc.jl 0.1.16</title><meta name="title" content="Vectors · SafePETSc.jl 0.1.16"/><meta property="og:title" content="Vectors · SafePETSc.jl 0.1.16"/><meta property="twitter:title" content="Vectors · SafePETSc.jl 0.1.16"/><meta name="description" content="Documentation for SafePETSc.jl 0.1.16."/><meta property="og:description" content="Documentation for SafePETSc.jl 0.1.16."/><meta property="twitter:description" content="Documentation for SafePETSc.jl 0.1.16."/><meta property="og:url" content="https://sloisel.github.io/SafePETSc.jl/api/vectors/"/><meta property="twitter:url" content="https://sloisel.github.io/SafePETSc.jl/api/vectors/"/><link rel="canonical" href="https://sloisel.github.io/SafePETSc.jl/api/vectors/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SafePETSc.jl 0.1.16</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../guide/vectors/">Vectors</a></li><li><a class="tocitem" href="../../guide/matrices/">Matrices</a></li><li><a class="tocitem" href="../../guide/solvers/">Linear Solvers</a></li><li><a class="tocitem" href="../../guide/strumpack/">STRUMPACK Support</a></li><li><a class="tocitem" href="../../guide/io/">Input/Output and Display</a></li><li><a class="tocitem" href="../../guide/mpi_programming/">MPI Programming</a></li><li><a class="tocitem" href="../../guide/distributed_refs/">Distributed Reference Management</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../safempi/">SafeMPI</a></li><li class="is-active"><a class="tocitem" href>Vectors</a><ul class="internal"><li><a class="tocitem" href="#Type"><span>Type</span></a></li><li><a class="tocitem" href="#Prefix-Types"><span>Prefix Types</span></a></li><li><a class="tocitem" href="#Constructors"><span>Constructors</span></a></li><li><a class="tocitem" href="#Helper-Constructors"><span>Helper Constructors</span></a></li><li><a class="tocitem" href="#Concatenation"><span>Concatenation</span></a></li><li><a class="tocitem" href="#Partitioning"><span>Partitioning</span></a></li><li><a class="tocitem" href="#Vector-Pooling"><span>Vector Pooling</span></a></li><li><a class="tocitem" href="#Conversion-and-Display"><span>Conversion and Display</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Row-wise-Operations"><span>Row-wise Operations</span></a></li><li><a class="tocitem" href="#Indexing"><span>Indexing</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li></ul></li><li><a class="tocitem" href="../matrices/">Matrices</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li></ul></li><li><a class="tocitem" href="../../developer/">Developer Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Vectors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vectors</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Vectors-API-Reference"><a class="docs-heading-anchor" href="#Vectors-API-Reference">Vectors API Reference</a><a id="Vectors-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Vectors-API-Reference" title="Permalink"></a></h1><p>Distributed vector operations in SafePETSc.</p><h2 id="Type"><a class="docs-heading-anchor" href="#Type">Type</a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.Vec"><a class="docstring-binding" href="#SafePETSc.Vec"><code>SafePETSc.Vec</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Vec{T}</code></pre><p>A distributed PETSc vector with element type <code>T</code>, managed by SafePETSc&#39;s reference counting system.</p><p><code>Vec{T}</code> is a type alias for <code>DRef{_Vec{T}}</code> and is released collectively when all ranks release their references. By default, released PETSc vectors are returned to an internal pool for reuse rather than destroyed immediately. To force destruction instead of pooling, set <code>ENABLE_VEC_POOL[] = false</code>, or call <code>clear_vec_pool!()</code> to free pooled vectors.</p><p><strong>Construction</strong></p><p>Use <a href="#SafePETSc.Vec_uniform"><code>Vec_uniform</code></a> or <a href="#SafePETSc.Vec_sum"><code>Vec_sum</code></a> to create distributed vectors:</p><pre><code class="language-julia hljs"># Create from uniform data (same on all ranks)
v = Vec_uniform([1.0, 2.0, 3.0, 4.0])

# Create from sparse contributions (summed across ranks)
using SparseArrays
v = Vec_sum(sparsevec([1, 3], [1.0, 3.0], 4))</code></pre><p><strong>Operations</strong></p><p>Vectors support standard arithmetic operations via broadcasting:</p><pre><code class="language-julia hljs">y = x .+ 1.0        # Element-wise addition
y .= 2.0 .* x       # In-place scaling
z = x .+ y          # Vector addition</code></pre><p>Matrix-vector multiplication:</p><pre><code class="language-julia hljs">y = A * x           # Matrix-vector product
LinearAlgebra.mul!(y, A, x)  # In-place version</code></pre><p>See also: <a href="#SafePETSc.Vec_uniform"><code>Vec_uniform</code></a>, <a href="#SafePETSc.Vec_sum"><code>Vec_sum</code></a>, <a href="../matrices/#SafePETSc.Mat"><code>Mat</code></a>, <a href="#SafePETSc.zeros_like"><code>zeros_like</code></a>, <a href="#SafePETSc.ENABLE_VEC_POOL"><code>ENABLE_VEC_POOL</code></a>, <a href="#SafePETSc.clear_vec_pool!"><code>clear_vec_pool!</code></a></p></div></section></details></article><h2 id="Prefix-Types"><a class="docs-heading-anchor" href="#Prefix-Types">Prefix Types</a><a id="Prefix-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Prefix-Types" title="Permalink"></a></h2><p>The <code>Prefix</code> type parameter controls PETSc configuration for vectors. See the <a href="../matrices/#Prefix-Types">Matrices API Reference</a> for details on <a href="../matrices/#SafePETSc.MPIAIJ"><code>MPIAIJ</code></a>, <a href="../matrices/#SafePETSc.MPIDENSE"><code>MPIDENSE</code></a>, and <a href="../matrices/#SafePETSc.prefix"><code>prefix</code></a>.</p><h2 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.Vec_uniform"><a class="docstring-binding" href="#SafePETSc.Vec_uniform"><code>SafePETSc.Vec_uniform</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Vec_uniform(v::Vector{T}; row_partition=default_row_partition(length(v), MPI.Comm_size(MPI.COMM_WORLD))) -&gt; Vec{T}</code></pre><p><strong>MPI Collective</strong></p><p>Create a distributed PETSc vector from a Julia vector, asserting uniform distribution across ranks (on MPI.COMM_WORLD).</p><ul><li><code>v::Vector{T}</code> must be identical on all ranks (<code>mpi_uniform</code>).</li><li><code>row_partition</code> is a Vector{Int} of length <code>nranks+1</code> with 1-based inclusive starts.</li><li>Returns a <code>Vec{T}</code> (aka <code>DRef{_Vec{T}}</code>) managed collectively; by default vectors are returned to a reuse pool when released, not immediately destroyed. Use <code>ENABLE_VEC_POOL[] = false</code> or <code>clear_vec_pool!()</code> to force destruction.</li></ul></div></section></details></article><article><details class="docstring" open="true"><summary id="SafePETSc.Vec_sum"><a class="docstring-binding" href="#SafePETSc.Vec_sum"><code>SafePETSc.Vec_sum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Vec_sum(v::SparseVector{T}; row_partition=default_row_partition(length(v), MPI.Comm_size(MPI.COMM_WORLD)), own_rank_only=false) -&gt; Vec{T}</code></pre><p><strong>MPI Collective</strong></p><p>Create a distributed PETSc vector by summing sparse vectors across ranks (on MPI.COMM_WORLD).</p><ul><li><code>v::SparseVector{T}</code> can differ across ranks; nonzeros are summed across all ranks.</li><li><code>row_partition</code> is a Vector{Int} of length <code>nranks+1</code> with 1-based inclusive starts.</li><li><code>own_rank_only::Bool</code> (default=false): if true, asserts that all nonzero indices fall within this rank&#39;s row partition.</li><li>Returns a <code>Vec{T}</code> managed collectively; by default vectors are returned to a reuse pool when released, not immediately destroyed. Use <code>ENABLE_VEC_POOL[] = false</code> or <code>clear_vec_pool!()</code> to force destruction.</li></ul><p>Uses <code>VecSetValues</code> with <code>ADD_VALUES</code> to sum contributions across ranks.</p></div></section></details></article><h2 id="Helper-Constructors"><a class="docs-heading-anchor" href="#Helper-Constructors">Helper Constructors</a><a id="Helper-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Constructors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.zeros_like"><a class="docstring-binding" href="#SafePETSc.zeros_like"><code>SafePETSc.zeros_like</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zeros_like(x::Vec{T}; T2::Type{S}=T) -&gt; Vec{S}</code></pre><p><strong>MPI Collective</strong></p><p>Create a new distributed vector with the same size and partition as <code>x</code>, filled with zeros.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Template vector to match size and partition</li><li><code>T2</code>: Element type of the result (defaults to same type as <code>x</code>)</li></ul><p>See also: <a href="#SafePETSc.ones_like"><code>ones_like</code></a>, <a href="#SafePETSc.fill_like"><code>fill_like</code></a>, <a href="#SafePETSc.Vec_uniform"><code>Vec_uniform</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="SafePETSc.ones_like"><a class="docstring-binding" href="#SafePETSc.ones_like"><code>SafePETSc.ones_like</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ones_like(x::Vec{T}; T2::Type{S}=T) -&gt; Vec{S}</code></pre><p><strong>MPI Collective</strong></p><p>Create a new distributed vector with the same size and partition as <code>x</code>, filled with ones.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Template vector to match size and partition</li><li><code>T2</code>: Element type of the result (defaults to same type as <code>x</code>)</li></ul><p>See also: <a href="#SafePETSc.zeros_like"><code>zeros_like</code></a>, <a href="#SafePETSc.fill_like"><code>fill_like</code></a>, <a href="#SafePETSc.Vec_uniform"><code>Vec_uniform</code></a></p></div></section></details></article><article><details class="docstring" open="true"><summary id="SafePETSc.fill_like"><a class="docstring-binding" href="#SafePETSc.fill_like"><code>SafePETSc.fill_like</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fill_like(x::Vec{T}, val; T2::Type{S}=typeof(val)) -&gt; Vec{S}</code></pre><p><strong>MPI Collective</strong></p><p>Create a new distributed vector with the same size and partition as <code>x</code>, filled with <code>val</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Template vector to match size and partition</li><li><code>val</code>: Value to fill the vector with</li><li><code>T2</code>: Element type of the result (defaults to type of <code>val</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = fill_like(x, 3.14)  # Create a vector like x, filled with 3.14</code></pre><p>See also: <a href="#SafePETSc.zeros_like"><code>zeros_like</code></a>, <a href="#SafePETSc.ones_like"><code>ones_like</code></a>, <a href="#SafePETSc.Vec_uniform"><code>Vec_uniform</code></a></p></div></section></details></article><h2 id="Concatenation"><a class="docs-heading-anchor" href="#Concatenation">Concatenation</a><a id="Concatenation-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenation" title="Permalink"></a></h2><p>Vectors can be concatenated using the same functions as matrices. See the <a href="../matrices/#Concatenation">Matrices API Reference</a> for <a href="../matrices/#Base.vcat"><code>vcat</code></a> and <a href="../matrices/#Base.hcat"><code>hcat</code></a>.</p><p>Note: Concatenating vectors returns <code>Mat{T,Prefix}</code> objects.</p><h2 id="Partitioning"><a class="docs-heading-anchor" href="#Partitioning">Partitioning</a><a id="Partitioning-1"></a><a class="docs-heading-anchor-permalink" href="#Partitioning" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.default_row_partition"><a class="docstring-binding" href="#SafePETSc.default_row_partition"><code>SafePETSc.default_row_partition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_row_partition(n::Int, nranks::Int) -&gt; Vector{Int}</code></pre><p><strong>MPI Non-Collective</strong></p><p>Create a default row partition that divides n rows equally among nranks.</p><p>Returns a Vector{Int} of length nranks+1 where partition[i] is the start row (1-indexed) for rank i-1.</p></div></section></details></article><h2 id="Vector-Pooling"><a class="docs-heading-anchor" href="#Vector-Pooling">Vector Pooling</a><a id="Vector-Pooling-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Pooling" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.ENABLE_VEC_POOL"><a class="docstring-binding" href="#SafePETSc.ENABLE_VEC_POOL"><code>SafePETSc.ENABLE_VEC_POOL</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">ENABLE_VEC_POOL</code></pre><p>Global flag to enable/disable vector pooling. Set to <code>false</code> to disable pooling.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="SafePETSc.clear_vec_pool!"><a class="docstring-binding" href="#SafePETSc.clear_vec_pool!"><code>SafePETSc.clear_vec_pool!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_vec_pool!()</code></pre><p><strong>MPI Non-Collective</strong></p><p>Clear all vectors from the pool, destroying them immediately. Useful for testing or explicit memory management.</p></div></section></details></article><article><details class="docstring" open="true"><summary id="SafePETSc.get_vec_pool_stats"><a class="docstring-binding" href="#SafePETSc.get_vec_pool_stats"><code>SafePETSc.get_vec_pool_stats</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_vec_pool_stats() -&gt; Dict</code></pre><p><strong>MPI Non-Collective</strong></p><p>Return statistics about the current vector pool state. Returns a dictionary with keys (nglobal, type) =&gt; count.</p></div></section></details></article><h2 id="Conversion-and-Display"><a class="docs-heading-anchor" href="#Conversion-and-Display">Conversion and Display</a><a id="Conversion-and-Display-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-and-Display" title="Permalink"></a></h2><p>Convert distributed vectors to Julia arrays for inspection and display:</p><article><details class="docstring" open="true"><summary id="Base.Vector-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T}"><a class="docstring-binding" href="#Base.Vector-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T}"><code>Base.Vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Vector(x::Vec{T}) -&gt; Vector{T}</code></pre><p><strong>MPI Collective</strong></p><p>Convert a distributed PETSc Vec to a Julia Vector by gathering all data to all ranks. This is a collective operation - all ranks must call it and will receive the complete vector.</p><p>This is primarily used for display purposes or small vectors. For large vectors, this operation can be expensive as it gathers all data to all ranks.</p></div></section><section><div><pre><code class="language-julia hljs">Vector(vt::LinearAlgebra.Adjoint{T, &lt;:Vec{T}}) -&gt; LinearAlgebra.Adjoint{T, Vector{T}}</code></pre><p><strong>MPI Collective</strong></p><p>Convert an adjoint of a distributed PETSc Vec to an adjoint Julia Vector. Equivalent to <code>Vector(parent(vt))&#39;</code>.</p><p>This is a collective operation - all ranks must call it and will receive the complete adjoint vector.</p></div></section></details></article><p>The universal <a href="../matrices/#SafePETSc.J"><code>J</code></a> function also converts vectors: <code>J(v)</code> is equivalent to <code>Vector(v)</code>.</p><p>Display methods (automatically used by <code>println</code>, <code>display</code>, etc.):</p><ul><li><code>show(io::IO, v::Vec)</code> - Display vector contents</li><li><code>show(io::IO, mime::MIME, v::Vec)</code> - Display with MIME type support</li></ul><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.io0"><a class="docstring-binding" href="#SafePETSc.io0"><code>SafePETSc.io0</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">io0(io=stdout; r::Set{Int}=Set{Int}([0]), dn=devnull)</code></pre><p><strong>MPI Non-Collective</strong></p><p>Return <code>io</code> if the current rank is in <code>r</code>, otherwise return <code>dn</code>.</p><p>This is useful for printing output only on specific ranks to avoid duplicate output.</p><p><strong>Parameters</strong></p><ul><li><code>io</code>: The IO stream to use (default: <code>stdout</code>)</li><li><code>r</code>: Set of ranks that should produce output (default: <code>Set{Int}([0])</code>)</li><li><code>dn</code>: The IO stream to return for non-selected ranks (default: <code>devnull</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Print only on rank 0 (default)
println(io0(), &quot;This prints only on rank 0&quot;)

# Print only on rank 2
println(io0(r=Set([2])), &quot;This prints only on rank 2&quot;)

# Print on ranks 0 and 3
println(io0(r=Set([0, 3])), &quot;This prints on ranks 0 and 3&quot;)

# Write to file only on rank 1
open(&quot;output.txt&quot;, &quot;w&quot;) do f
    println(io0(f; r=Set([1])), &quot;This writes only on rank 1&quot;)
end</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="SafePETSc.own_row-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T}"><a class="docstring-binding" href="#SafePETSc.own_row-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T}"><code>SafePETSc.own_row</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">own_row(v::Vec{T}) -&gt; UnitRange{Int}</code></pre><p><strong>MPI Non-Collective</strong></p><p>Return the range of indices owned by the current rank for vector v.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = Vec_uniform([1.0, 2.0, 3.0, 4.0])
range = own_row(v)  # e.g., 1:2 on rank 0</code></pre></div></section><section><div><pre><code class="language-julia hljs">own_row(A::Mat{T,Prefix}) -&gt; UnitRange{Int}</code></pre><p><strong>MPI Non-Collective</strong></p><p>Return the range of row indices owned by the current rank for matrix A.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = Mat_uniform([1.0 2.0; 3.0 4.0; 5.0 6.0; 7.0 8.0])
range = own_row(A)  # e.g., 1:2 on rank 0</code></pre></div></section></details></article><h2 id="Row-wise-Operations"><a class="docs-heading-anchor" href="#Row-wise-Operations">Row-wise Operations</a><a id="Row-wise-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Row-wise-Operations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="SafePETSc.map_rows"><a class="docstring-binding" href="#SafePETSc.map_rows"><code>SafePETSc.map_rows</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">map_rows(f::Function, A::Union{Vec{T},Mat{T,Prefix}}...; col_partition=nothing) -&gt; Union{Vec{T},Mat{T,MPIDENSE}}</code></pre><p><strong>MPI Collective</strong></p><p>Apply a function <code>f</code> to corresponding rows across distributed PETSc vectors and matrices.</p><p>Similar to the native Julia pattern <code>vcat((f.((eachrow.(A))...))...)</code>, but works with distributed PETSc objects. The function <code>f</code> is applied row-wise to each input, and the results are concatenated into a new distributed vector or matrix.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: Function to apply to each row. Should accept as many arguments as there are inputs.</li><li><code>A...::Union{Vec{T},Mat{T,Prefix}}</code>: One or more distributed vectors or matrices. All inputs must have the same number of rows and compatible row partitions.</li><li><code>col_partition::Union{Vector{Int},Nothing}</code>: Column partition for result matrix (default: use default<em>row</em>partition). Only used when <code>f</code> returns an adjoint vector (creating a matrix).</li></ul><p><strong>Return value</strong></p><p>Returns <code>Vec{T}</code> or <code>Mat{T,MPIDENSE}</code>. The return type depends on what <code>f</code> returns:</p><ul><li>If <code>f</code> returns a scalar or Julia Vector → returns a <code>Vec{T}</code></li><li>If <code>f</code> returns an adjoint Julia Vector (row vector) → returns a <code>Mat{T,MPIDENSE}</code></li></ul><p><strong>Size behavior</strong></p><p>If inputs have <code>m</code> rows and <code>f</code> returns:</p><ul><li>A scalar or adjoint vector → result has <code>m</code> rows</li><li>An <code>n</code>-dimensional vector → result has <code>m*n</code> rows</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example 1: Sum rows of a matrix
B = Mat_uniform(randn(5, 3))
sums = map_rows(sum, B)  # Returns Vec{Float64} with 5 elements

# Example 2: Compute [sum, product] for each row (returns matrix)
stats = map_rows(x -&gt; [sum(x), prod(x)]&#39;, B)  # Returns 5×2 Mat{Float64,MPIDENSE}

# Example 3: Combine matrix and vector row-wise
C = Vec_uniform(randn(5))
combined = map_rows((x, y) -&gt; [sum(x), prod(x), y[1]]&#39;, B, C)  # Returns 5×3 Mat{Float64,MPIDENSE}</code></pre><p><strong>Implementation notes</strong></p><ul><li>This is a collective operation; all ranks must call it with compatible arguments</li><li>The function <code>f</code> is assumed to be homogeneous (always returns the same type of output)</li><li>For vectors, <code>f</code> receives a scalar value per row</li><li>For matrices, <code>f</code> receives a view of the row (similar to eachrow)</li><li>Matrix results always use MPIDENSE prefix</li></ul></div></section></details></article><h2 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h2><p>Non-collective element and range access:</p><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T, Int64}"><a class="docstring-binding" href="#Base.getindex-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(v::Vec{T}, i::Int) -&gt; T</code></pre><p><strong>MPI Non-Collective</strong></p><p>Get the value at index i from a distributed vector.</p><p>The index i must be wholly contained in the current rank&#39;s ownership range. If not, the function will abort with an error message and stack trace.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = Vec_uniform([1.0, 2.0, 3.0, 4.0])
# On rank that owns index 2:
val = v[2]  # Returns 2.0</code></pre></div></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T, UnitRange{Int64}}"><a class="docstring-binding" href="#Base.getindex-Tuple{SafePETSc.SafeMPI.DRef{SafePETSc._Vec{T}} where T, UnitRange{Int64}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(v::Vec{T}, range::UnitRange{Int}) -&gt; Vector{T}</code></pre><p><strong>MPI Non-Collective</strong></p><p>Extract a contiguous range of values from a distributed vector.</p><p>The range must be wholly contained in the current rank&#39;s ownership range. If not, the function will abort with an error message and stack trace.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">v = Vec_uniform([1.0, 2.0, 3.0, 4.0])
# On rank that owns indices 2:3:
vals = v[2:3]  # Returns [2.0, 3.0]</code></pre></div></section></details></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><h3 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h3><p>Vectors support standard Julia arithmetic operations via broadcasting:</p><pre><code class="language-julia hljs">y = x .+ 1.0        # Element-wise addition
y = 2.0 .* x        # Scaling
z = x .+ y          # Vector addition
y .= x .+ 1.0       # In-place operation</code></pre><p>Standard operators are also overloaded:</p><pre><code class="language-julia hljs">z = x + y           # Addition
z = x - y           # Subtraction
z = -x              # Negation</code></pre><h3 id="Linear-Algebra"><a class="docs-heading-anchor" href="#Linear-Algebra">Linear Algebra</a><a id="Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra" title="Permalink"></a></h3><pre><code class="language-julia hljs">y = A * x                              # Matrix-vector multiplication
LinearAlgebra.mul!(y, A, x)            # In-place multiplication
w = v&#39; * A                             # Adjoint-vector times matrix
LinearAlgebra.mul!(w, v&#39;, A)           # In-place</code></pre><h3 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h3><pre><code class="language-julia hljs">T = eltype(v)                          # Element type
n = length(v)                          # Vector length
n = size(v, 1)                         # Size in dimension 1</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../safempi/">« SafeMPI</a><a class="docs-footer-nextpage" href="../matrices/">Matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 21:26">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
