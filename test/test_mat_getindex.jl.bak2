using Test
using MPI
using SafePETSc
SafePETSc.Init()
using PETSc
using SafePETSc.SafeMPI
using LinearAlgebra
include(joinpath(@__DIR__, "mpi_test_harness.jl"))
using .MPITestHarness

const _VERBOSE = get(ENV, "VERBOSE_MAT_GETINDEX", "0") == "1"

# PETSc is initialized by SafePETSc.Init()

comm = MPI.COMM_WORLD
rank = MPI.Comm_rank(comm)
nranks = MPI.Comm_size(comm)

if rank == 0
    println("[DEBUG] Mat getindex test starting")
    flush(stdout)
end

# Test body extracted for reuse
function _mat_getindex_tests_body()
    if rank == 0
        println("[DEBUG] Mat getindex Test 1 starting")
        flush(stdout)
    end

    # Test 1: Extract column from a simple matrix
    A_data = Float64[1 2 3; 4 5 6; 7 8 9; 10 11 12]  # 4×3 matrix
    A = SafePETSc.Mat_uniform(A_data)

    # Extract second column: should be [2, 5, 8, 11]
    v = A[:, 2]

    @test v isa SafeMPI.DRef
    @test v.obj isa SafePETSc._Vec
    @test length(v) == 4

    # Verify the vector has the correct row partition
    @test v.obj.row_partition == A.obj.row_partition

    # Extract the local portion and verify values
    local_view = PETSc.unsafe_localarray(v.obj.v; read=true)
    try
        row_lo = A.obj.row_partition[rank+1]
        row_hi = A.obj.row_partition[rank+2] - 1
        expected = A_data[row_lo:row_hi, 2]
        @test all(local_view .≈ expected)
    finally
        Base.finalize(local_view)
    end

    SafeMPI.check_and_destroy!()
    MPI.Barrier(comm)

    # Test 2: Extract first column
    B_data = Float64[10 20 30 40; 50 60 70 80; 100 110 120 130]  # 3×4 matrix
    B = SafePETSc.Mat_uniform(B_data)

    v1 = B[:, 1]
    @test length(v1) == 3

    local_view = PETSc.unsafe_localarray(v1.obj.v; read=true)
    try
        row_lo = B.obj.row_partition[rank+1]
        row_hi = B.obj.row_partition[rank+2] - 1
        expected = B_data[row_lo:row_hi, 1]
        @test all(local_view .≈ expected)
    finally
        Base.finalize(local_view)
    end

    SafeMPI.check_and_destroy!()
    MPI.Barrier(comm)

    # Test 3: Extract last column
    v_last = B[:, 4]
    @test length(v_last) == 3

    local_view = PETSc.unsafe_localarray(v_last.obj.v; read=true)
    try
        row_lo = B.obj.row_partition[rank+1]
        row_hi = B.obj.row_partition[rank+2] - 1
        expected = B_data[row_lo:row_hi, 4]
        @test all(local_view .≈ expected)
    finally
        Base.finalize(local_view)
    end

    SafeMPI.check_and_destroy!()
    MPI.Barrier(comm)

    # Test 4: Test with rectangular matrix (more rows than columns)
    C_data = reshape(Float64.(1:20), 10, 2)  # 10×2 matrix
    C = SafePETSc.Mat_uniform(C_data)

    v_c1 = C[:, 1]
    @test length(v_c1) == 10

    local_view = PETSc.unsafe_localarray(v_c1.obj.v; read=true)
    try
        row_lo = C.obj.row_partition[rank+1]
        row_hi = C.obj.row_partition[rank+2] - 1
        expected = C_data[row_lo:row_hi, 1]
        @test all(local_view .≈ expected)
    finally
        Base.finalize(local_view)
    end

    SafeMPI.check_and_destroy!()
    MPI.Barrier(comm)

    # Test 5: Test with rectangular matrix (more columns than rows)
    D_data = reshape(Float64.(1:24), 3, 8)  # 3×8 matrix
    D = SafePETSc.Mat_uniform(D_data)

    v_d5 = D[:, 5]
    @test length(v_d5) == 3

    local_view = PETSc.unsafe_localarray(v_d5.obj.v; read=true)
    try
        row_lo = D.obj.row_partition[rank+1]
        row_hi = D.obj.row_partition[rank+2] - 1
        expected = D_data[row_lo:row_hi, 5]
        @test all(local_view .≈ expected)
    finally
        Base.finalize(local_view)
    end

    SafeMPI.check_and_destroy!()
    MPI.Barrier(comm)

    if rank == 0
        println("[DEBUG] Mat getindex tests completed")
        flush(stdout)
    end
end

# Keep output tidy and aggregate at the end
if _VERBOSE
    @testset "Mat getindex tests" begin
        _mat_getindex_tests_body()
    end
else
    ts = @testset MPITestHarness.QuietTestSet "Mat getindex tests" begin
        _mat_getindex_tests_body()
    end
end


if !_VERBOSE
# Aggregate per-rank counts and print a single summary on root
local_counts = [
    get(ts.counts, :pass, 0),
    get(ts.counts, :fail, 0),
    get(ts.counts, :error, 0),
    get(ts.counts, :broken, 0),
    get(ts.counts, :skip, 0),
]

global_counts = similar(local_counts)
MPI.Reduce!(local_counts, global_counts, +, 0, comm)

if rank == 0
    println("Test Summary: Mat getindex tests (aggregated across $(nranks) ranks)")
    println("  Pass: $(global_counts[1])  Fail: $(global_counts[2])  Error: $(global_counts[3])  Broken: $(global_counts[4])  Skip: $(global_counts[5])")
end

MPI.Barrier(comm)

if global_counts[2] > 0 || global_counts[3] > 0
    Base.exit(1)
end

# Ensure all ranks reach this point before deciding outcome
MPI.Barrier(comm)

if rank == 0
    println("[DEBUG] Mat getindex test file completed successfully")
    flush(stdout)
end
end # !_VERBOSE

# Note: We don't call MPI.Finalize() here because Julia's MPI.jl
# automatically finalizes MPI at exit via atexit hook
